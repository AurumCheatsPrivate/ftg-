# requires: pydub numpy requests 
 
import io, math, os, re 
 
import numpy as np 
import requests 
from pydub import AudioSegment, effects 
from telethon import types 
 
from .. import loader, utils 
 
 
@loader.tds 
class AudioEditorMod(loader.Module): 
    """Module for working with sound""" 
    strings = { 
        "name": "AudioEditor", 
        "downloading": "<b>[{}]</b> Downloading...", 
        "working"    : "<b>[{}]</b> Working...", 
        "exporting"  : "<b>[{}]</b> Exporting...", 
        "set_value"  : "<b>[{}]</b> Specify the level from {} to {}...", 
        "reply"      : "<b>[{}]</b> reply to audio...", 
        "set_fmt"    : "<b>[{}]</b> Specify the format of output audio...", 
        "set_time"   : "<b>[{}]</b> Specify the time in the format start(ms):end(ms)" 
        } 
 
    async def basscmd(self, m): 
        """.bass [level bass'Ð° 2-100 (Default 2)] <reply to audio> 
        BassBoost""" 
        args = utils.get_args_raw(m) 
        if not args: lvl = 2.0 
        else: 
            if re.match(r'^\d+(\.\d+){0,1}$', args) and (1.0 < float(args) < 100.1): lvl = float(args) 
            else: return await utils.answer(m, self.strings("set_value", m).format('BassBoost', 2.0, 100.0)) 
        audio = await get_audio(self, m, "BassBoost") 
        if not audio: return 
        sample_track = list(audio.audio.get_array_of_samples()) 
        out = (audio.audio - 0).overlay(audio.audio.low_pass_filter(int(round((3 * np.std(sample_track) / (math.sqrt(2)) - np.mean(sample_track)) * 0.005))) + lvl) 
        await go_out(m, audio, out, audio.pref, f"{audio.pref} {lvl}lvl") 
 
    async def fvcmd(self, m): 
        """.fv [level 2-100 (Default 25)] <reply to audio> 
        Distort""" 
        args = utils.get_args_raw(m) 
        if not args: lvl = 25.0 
        else: 
            if re.match(r'^\d+(\.\d+){0,1}$', args) and (1.0 < float(args) < 100.1): lvl = float(args) 
            else: return await utils.answer(m, self.strings("set_value", m).format('Distort', 2.0, 100.0)) 
        audio = await get_audio(self, m, "Distort") 
        if not audio: return 
        out = audio.audio + lvl 
        await go_out(m, audio, out, audio.pref, f"{audio.pref} {lvl}lvl") 
 
    async def echoscmd(self, m): 
        """.echos <reply to audio> 
            Echo effect""" 
        audio = await get_audio(self, m, "Echo") 
        if not audio: return 
        out = AudioSegment.empty() 
        n = 200 
        none = io.BytesIO() 
        out += audio.audio + AudioSegment.from_file(none) 
        for i in range(5): 
            echo = audio.audio - 10 
            out = out.overlay(audio.audio, n) 
            n += 200 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def volupcmd(self, m): 
        """.volup <reply to audio> 
            VolUp 10dB""" 
        audio = await get_audio(self, m, "+10dB") 
        if not audio: return 
        out = audio.audio + 10 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def voldwcmd(self, m): 
        """.voldw <reply to audio> 
            VolDw 10dB""" 
        audio = await get_audio(self, m, "-10dB") 
        if not audio: return 
        out = audio.audio - 10 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def revscmd(self, m): 
        """.revs <reply to audio> 
            Reverse audio""" 
        audio = await get_audio(self, m, "Reverse") 
        if not audio: return 
        out = audio.audio.reverse() 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def repscmd(self, m): 
        """.reps <reply to audio> 
            Repeat audio 2 times""" 
        audio = await get_audio(self, m, "Repeat") 
        if not audio: return 
        out = audio.audio * 2 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def slowscmd(self, m): 
        """.slows <reply to audio> 
            SlowDown 0.5x""" 
        audio = await get_audio(self, m, "SlowDown") 
        if not audio: return 
        s2 = audio.audio._spawn(audio.audio.raw_data, overrides={ 
            "frame_rate": int(audio.audio.frame_rate * 0.5)}) 
        out = s2.set_frame_rate(audio.audio.frame_rate) 
        await go_out(audio.message, audio, out, audio.pref, audio.pref, audio.duration * 2) 
 
    async def fastscmd(self, m): 
        """.fasts <reply to audio> 
        SpeedUp 1.5x""" 
        audio = await get_audio(self, m, "SpeedUp") 
        if not audio: return 
        s2 = audio.audio._spawn(audio.audio.raw_data, overrides={ 
            "frame_rate": int(audio.audio.frame_rate * 1.5)}) 
        out = s2.set_frame_rate(audio.audio.frame_rate) 
        await go_out(audio.message, audio, out, audio.pref, audio.pref, 
                     round(audio.duration / 2)) 
 
    async def rightscmd(self, m): 
        """.rights <reply to audio> 
            Push sound to right channel""" 
        audio = await get_audio(self, m, "Right channel") 
        if not audio: return 
        out = effects.pan(audio.audio, +1.0) 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def leftscmd(self, m): 
        """.lefts <reply to audio> 
            Push sound to left channel""" 
        audio = await get_audio(self, m, "Left channel") 
        if not audio: return 
        out = effects.pan(audio.audio, -1.0) 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def normscmd(self, m): 
        """.norms <reply to audio> 
            Normalize sound (from quiet to normal)""" 
        audio = await get_audio(self, m, "Normalization") 
        if not audio: return 
        out = effects.normalize(audio.audio) 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def tovscmd(self, m): 
        """.tovs <reply to audio> 
            Convert to voice message""" 
        f = utils.get_args_raw(m) 
        audio = await get_audio(self, m, "Voice") 
        if not audio: return 
        audio.voice = True 
        await go_out(audio.message, audio, audio.audio, audio.pref, audio.pref) 
     
    async def convscmd(self, m): 
        """.convs <reply to audio> [audio_format (ex. `mp3`)] 
            Convert audio to some format""" 
        f = utils.get_args(m) 
        if not f: return await utils.answer(m, self.strings("set_fmt", m).format('Converter')) 
        audio = await get_audio(self, m, "Converter") 
        if not audio: return 
        await go_out(audio.message, audio, audio.audio, audio.pref, f"Converted to {f[0].lower()}", fmt=f[0].lower()) 
     
    async def byrobertscmd(self, m): 
        '''.byroberts <reply to audio> 
            Add at the end "Directed by Robert B Weide"''' 
        audio = await get_audio(self, m, "Directed by...") 
        if not audio: return 
        out = audio.audio + AudioSegment.from_file(io.BytesIO(requests.get( 
            "https://raw.githubusercontent.com/D4n13l3k00/files-for-modules/master/directed.mp3").content)).apply_gain( 
            +8) 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
 
    async def cutscmd(self, m): 
        """.cuts <start(ms):end(ms)> <reply to audio> 
        Cut audio""" 
        args = utils.get_args_raw(m) 
        if not args: return await utils.answer(m, self.strings("set_time", m).format('Cut')) 
        else: 
            r = re.compile(r'^(?P<start>\d+){0,1}:(?P<end>\d+){0,1}$') 
            ee = r.match(args) 
            if ee: 
                start = int(ee.group('start')) if ee.group('start') else 0 
                end   = int(ee.group('end')) if ee.group('end') else 0 
            else: return await utils.answer(m, self.strings("set_time", m).format('Cut')) 
        audio = await get_audio(self, m, "Cut") 
        if not audio: return 
        out = audio.audio[start:end if end else len(audio.audio)-1] 
        await go_out(audio.message, audio, out, audio.pref, audio.pref) 
async def get_audio(self, m, pref): 
    class audio_ae_class(): 
        audio = None 
        message = No
